{# type=models,filename=src/services.rs,min_version=0.5.0 #}
{%- import "macros.j2" as m -%}
{%- import "extra.j2" as e -%}
{{ m::do_not_modify() }}

use axum::{
    body::{Body, HttpBody},
    extract::{FromRequest, State, Path},
    handler::{future::IntoServiceFuture, Handler},
    http::Request,
    http::{request::Parts, StatusCode},
    response::{Json, IntoResponse, Response},
    routing::{self, on_service, MethodFilter},
    Router, BoxError,
};
use futures::{future::LocalBoxFuture, Future};
use std::{
    convert::Infallible,
    marker::PhantomData,
    pin::Pin,
    task::{Context, Poll},
};
use diesel_async::{
    pooled_connection::AsyncDieselConnectionManager, AsyncPgConnection, RunQueryDsl,
};
use crate::Pool;
use crate::internal_error;
use crate::models::{*};
use crate::schema::{*};
use diesel::QueryDsl;
use diesel::SelectableHelper;
{%- for model in models %}
{%- set model_name = model.object.name %}
{%- if not options.skipModels or options.skipModels and not model_name in options.skipModels %}
pub async fn get_{{ model_name | plural | lower }}(State(pool): State<Pool>) -> Result<Json<Vec<{{model.object.name}}>>, (StatusCode, String)> {
    let mut conn = pool.get().await.map_err(internal_error)?;

    let res = {{ model_name | lower }}::table
        .select({{ model_name }}::as_select())
        .load(&mut conn)
        .await
        .map_err(internal_error)?;
    Ok(Json(res))
}

pub async fn post_{{ model_name | plural | lower }}(State(pool): State<Pool>, Json(new_value): Json<{{ model_name }}Dto>) -> Result<Json<{{model.object.name}}>, (StatusCode, String)> {
    let mut conn = pool.get().await.map_err(internal_error)?;

    let res = diesel::insert_into({{ model_name | lower }}::table)
        .values(new_value)
        .returning({{ model_name }}::as_returning())
        .get_result(&mut conn)
        .await
        .map_err(internal_error)?;
    Ok(Json(res))
}

pub async fn get_{{ model_name | lower }}(State(pool): State<Pool>,Path(id): Path<uuid::Uuid>) -> Result<Json<{{ model.object.name }}>, (StatusCode, String)> {
    let mut conn = pool.get().await.map_err(internal_error)?;

    let res = {{ model_name | lower }}::table
        .find(id)
        .select({{ model_name }}::as_select())
        .first(&mut conn)
        .await
        .map_err(internal_error)?;

    Ok(Json(res))
}

pub async fn update_{{ model_name | lower }}(State(pool): State<Pool>,Path(id): Path<uuid::Uuid>, Json(new_value): Json<{{ model_name }}>) -> Result<StatusCode, String> {
    let mut conn = pool.get().await.map_err(internal_error)?;
    let res = diesel::update({{ model_name | lower }}::table)
        .set(new_value)
        .execute(&mut conn)
        .await
        .map_err(internal_error)?;
    Ok(StatusCode::NO_CONTENT)
}

pub async fn partial_update_{{ model_name | lower }}(State(pool): State<Pool>,Path(id): Path<uuid::Uuid>, Json(new_value): Json<{{ model_name }}>) -> Result<StatusCode, String> {
    let mut conn = pool.get().await.map_err(internal_error)?;
    let res = diesel::update({{ model_name | lower }}::table)
        .set(new_value)
        .execute(&mut conn)
        .await
        .map_err(internal_error)?;
    Ok(StatusCode::NO_CONTENT)
}

pub async fn delete_{{ model_name | lower }}(State(pool): State<Pool>,Path(id): Path<uuid::Uuid>) -> Result<StatusCode, String> {
    let mut conn = pool.get().await.map_err(internal_error)?;

    diesel::delete({{ model_name | lower }}::table.filter(id.eq(id)))
        .execute(&mut conn)
        .await
        .map_err(internal_error)?;
    Ok(StatusCode::NO_CONTENT)
}

{%- endif %}
{% endfor %}